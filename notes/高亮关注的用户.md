# 高亮关注的用户

- 储存关注用户的 id 列表。不储存用户名称，这一方面是为了减少数据体积，一方面是因为名称可能随时更改，而下载器并不知道何时发生了更改。
- 需要保存当前登录用户的 id，以区分用户可能切换多个 pixiv 账户的情况
- 需要储存每次更新时的时间戳，以实现定时更新以及过期失效等功能（目前时间戳并未实际使用）
- 应该在合适的时候更新关注列表

数据格式如下：

```ts
{
  /** 指示这个对象属于哪个用户 id **/
  user: string
  /** 此用户的关注用户的 id 列表 **/
  following: string[]
  /**此用户的关注用户总数。注意这是公开和非公开关注的数量之和。因为本程序不区分一个关注是公开的还是非公开的 */
  total: number
  /** 最后一次更新本地数据的时间戳 **/
  time: number
}[]
```

有了关注列表之后，查找页面上所有的用户链接，提取用户 id 进行判断。如果关注了该用户，则为这个元素添加特定的样式。

## 数据如何储存？

我计划保存关注用户的 id，并且在页面启动时读取到内存中以备使用。

Pixiv 的用户 id 目前是 8 位数字，考虑到未来的变化，按照 10 位数字预估。（10 位数字是十亿级别，最大可以到 99 亿，够地球上所有人使用了）

### 存储到 localStorage

同一个站点下 localStorage 只能保存最多 5MB 数据。

目前 pixiv.net 在 localStorage 里存储的数据量比较少，我粗略翻看了以下，估计总共不会超过 100 KB。

如果仅考虑存储用户 id，那么是够用的。

如果一个用户 id 占用 10 Byte，大约可以储存 500,000 个用户 id。

潜在问题：

1. 有些用户喜欢清理缓存数据，这会导致储存的用户 id 被清空。（不过问题不大，因为重新获取一遍关注列表通常不会花费很久）
2. 在无痕模式下，需要重新获取关注列表。
3. 或许会有其他的扩展或脚本在 Pixiv 存储大量数据，导致 localStorage 空间不够用（这是个不确定因素，而且可能性很低）。

### 存储到 IndexedDB

IndexedDB 的存储量很大，通常都是 GB 级别，存储关注列表的 id 肯定够用了。

潜在问题：

1. 有些用户喜欢清理缓存数据，这会导致储存的用户 id 被清空。（不过问题不大，因为重新获取一遍关注列表通常不会花费很久）
2. 在无痕模式下，需要重新获取关注列表。
3. IndexedDB 的 API 操作稍显复杂

### 储存到 chrome.storage.local

chrome.storage.local 的储存上限是 10 MiB。

https://developer.chrome.com/docs/extensions/reference/storage/#property-local

它里面现在储存的有下载器的设置，以及下载时的一些任务数据。用它储存关注列表一般也够用。

而且 chrome.storage.local 里的数据更持久。它不仅不受清理缓存的影响，而且在无痕模式下里面的数据依然生效，这不同于其他两种方式。

### 总结

localStorage 和 IndexedDB 相比，主要区别在于可存储的数据体积不同。不过这项功能的数据体积不会太大，所以 localStorage 更方便。 

而和 localStorage 相比，chrome.storage.local 的优势是数据不会因为清理缓存被删除，并且在无痕模式里也可以共用数据，不需要重新获取数据。

但是使用 chrome.storage.local 的话，需要考虑其他数据会占用多少空间。

现在有 3 种数据会存储在 chrome.storage.local 里：

1. 下载器的设置。这通常不会超过 10 KB。
2. background 里的 batchNo，体积很小，可以忽略不计。
3. background 里的 idList，有可能比较多。（当下载器处于下载途中时，这项数据会不断增多。当发起下载的标签页关闭后，下载器会清除该标签页所产生的这项数据）

主要是 idList，当前台页面发送下载任务时，后台页面会存储这个任务的 id。如果某个标签页里下载了非常多的文件（假设有 100,000 个），那么这些 id 粗略估计可能会占用 1 - 2 MB 空间。如果文件数量更多，那么占用的空间也会更多。

但是考虑到关注的用户数量通常只有几千个，按一万个算，只保存其 id，那么只占用约 100 KB 空间，所以放在 chrome.storage.local 里应该是没问题的。

再加上后文提到的在后台统一管理关注列表，所以必须存储在 chrome.storage.local 里。

## 何时获取/更新关注列表？

### 不定时检查更新

不定时获取关注列表第一页的数据，如果关注总数 total 变化则表示需要重新获取数据。

由于用户可以取消关注任意位置（索引）的用户，所以下载器不知道用户具体的操作，此时必须执行全量更新。

### 监听用户新增或取消关注的动作

如果用户点击关注或取消关注按钮时，下载器能够检测到这次操作的详细信息，则不必请求 API 来检查总数，而是直接操作在数据里添加或删除对应的 id 即可。

这需要立即更新数据。并且这种更新不需要下载器发起网络请求，是瞬间完成的。

#### 方法 1：监听网络请求

应该可以使用 webRequest 权限达成目的。

https://developer.chrome.com/docs/extensions/reference/webRequest/#examples

已经成功实现并使用。

由于此功能需要新增 webRequest 权限，我本来以为这会增加一个新的权限提醒，所以打算先提醒用户，下一次更新再添加这个权限。但是我试了一下并没有增加新的权限提醒，所以可以直接发布。

#### 方法 2：检测按钮元素

这是个下策，相比监听网络请求，这个方法唯一的优点是不需要请求新权限，可以避免一些用户的担心。

但是这个方法先不说是否能实现，就算实现了，以后 Pixiv 页面元素改版也可能导致失效。

而且关注按钮也可能有不同类型，这使情况变得更加复杂。

在作品页面内，页面右侧的作者的关注按钮的 html 代码如下：

```html
英语的关注和取消关注按钮
<button class="sc-bdnxRM jvCTkj sc-dlnjwi kmHafz sc-1obql3d-0 Rlftz gtm-undefined sc-1obql3d-0 Rlftz gtm-undefined" data-gtm-user-id="89469319" data-click-action="click" data-click-label="follow" height="32">Follow</button>
<button class="sc-bdnxRM jvCTkj sc-dlnjwi eLIyxB sc-1obql3d-0 Rlftz gtm-undefined sc-1obql3d-0 Rlftz gtm-undefined" data-gtm-user-id="89469319" data-click-action="click" data-click-label="follow" height="32">Following</button>

日语的关注和取消关注按钮
<button class="sc-bdnxRM jvCTkj sc-dlnjwi kmHafz sc-1obql3d-0 Rlftz gtm-undefined sc-1obql3d-0 Rlftz gtm-undefined" data-gtm-user-id="89469319" data-click-action="click" data-click-label="follow" height="32">フォローする</button>
<button class="sc-bdnxRM jvCTkj sc-dlnjwi eLIyxB sc-1obql3d-0 Rlftz gtm-undefined sc-1obql3d-0 Rlftz gtm-undefined" data-gtm-user-id="89469319" data-click-action="click" data-click-label="follow" height="32">フォロー中</button>

中文的关注和取消关注按钮
<button class="sc-bdnxRM jvCTkj sc-dlnjwi kmHafz sc-1obql3d-0 Rlftz gtm-undefined sc-1obql3d-0 Rlftz gtm-undefined" data-gtm-user-id="89469319" data-click-action="click" data-click-label="follow" height="32">加关注</button>
<button class="sc-bdnxRM jvCTkj sc-dlnjwi eLIyxB sc-1obql3d-0 Rlftz gtm-undefined sc-1obql3d-0 Rlftz gtm-undefined" data-gtm-user-id="89469319" data-click-action="click" data-click-label="follow" height="32">已关注</button>
```

可以看出，在按钮为关注或取消关注时，只有两点不同：
1. 有一个 className 不同。未关注时按钮是蓝色，有个 `kmHafz`，关注后按钮是灰色，变成 `eLIyxB`。
2. 按钮文字不同。但是根据语言不同，文字也有多个版本，这也会造成麻烦。

除了这两个区别，无法得知点击这个按钮时的动作是关注还是取消关注。

目前并未使用此方法。

## 多个页面间同时更新数据的问题

由于用户可能打开多个标签页，当关注数据变化后，有可能多个标签页全都进行全量更新。

考虑一种情况：假设用户打开了 10 个页面，在其中一个页面里添加了一个新的关注。其他 9 个页面不知道这个动作，只能在检测到关注数量变化时全局更新。

另外，如果下载器的本地存储里没有当前用户的关注数据，而且用户在短时间内连续打开多个页面，那么它们也会全部发起请求来获取数据。

目前下载器已经在后台统一管理所有页里请求数据的操作，以及对本地数据的操作，解决了大多数问题。

### 优化措施：定时检查更新的时间间隔设置为随机值

例如，设置 10 - 30 分钟之间的随机时间来作为定时器的执行间隔。

这是为了避免一种情况：短时间内连续打开多个 pixiv 页面，如果间隔相同的话，那么它们会几乎同时检查更新。如果需要更新，那么它们会同时开始请求数据。这会造成浪费。

所以让它们把时间错开比较好。

预估一次完整更新需要的时间：假设有 10000 个关注，每页请求 100 个，需要 100 次请求，网速正常的情况下，需要差不多 60 秒，或更久一些。

间隔的时间应该大于一次完成更新所需的时间。

目前暂定检查更新的时间间隔最小值为 5 分钟，然后产生 0 - 10 分钟之间的随机数，两者相加，成为这个页面检查更新的时间。

这个优化措施已经实行，但是它无法解决一些特殊情况，例如：
1. 用户在短时间内打开多个 pixiv 页面，而此时本地没有关注数据，那么这些页面会第一时间全都开始请求关注数据。

所以最好的解决办法还是在后台统一管理。

### 方法1：更新前检查上次更新时间

此方法未使用。

更新前检查唯一数据源（localStorage）里的 time 时间戳（上一次更新时间）。如果该页面内存中的数据的时间已经是旧的，则应该先同步数据源里的数据，然后再检查更新。

这个方法操作较为简单，可行性高。

但是，依然可能会出现多个标签页同时更新，或者一个正在更新途中，另一个也开始更新的情况。

### 方法2：更新时设置两个时间标记

此方法未使用。

设置两个标记：

1. 开始更新的时间戳
2. 更新完成时的时间戳

当一个页面在检查更新之前，先读取开始的时间戳。如果时间戳存在，那么肯定之前已经有页面开始更新了。

那么此时再读取完成的时间戳，如果时间戳存在并且小于开始时间戳，说明更新未完成，此时不进行更新。

但是这个方法有个漏洞：如果某次更新过程中页面被用户关闭，那么就会是开始时间戳大于完成时间戳的情况，这会阻止所有页面进行更新。

为了解决这个漏洞，取两个时间戳中最大的值，如果最大值距现在超过了 10 分钟，则将完成时间设置为现在，使下载器可以强制进行更新。

### 方法3：交给后台统一管理

已使用此方法。

把数据储存在 chrome.storage 里，由后台读取并派发给前台页面。

前台页面需要发起请求更新数据时，需要先通知后台，由后台决定是否可以进行更新。

这个方法可能是效果最佳的，但是实现起来麻烦。一些担心：
1. 后台脚本可能会被销毁，再加上 chrome.storage 的读写是异步的，所以实际用起来没那么方便
2. 如果前台页面非常多，那么每次数据更新后，后台需要向每个前台页面都发送消息，会不会引起性能问题？

在实践之后，我觉得不需要太多担心，这个方案是可行的。现在已经实施了这个方法。

## 清除长时间未使用的用户的数据

用户可能切换登录多个 pixiv 账号，所以下载器可能保存了多个账号的关注列表数据。

如果某个账号的本地数据没有更新，那么他数据里的 `time` 就不会变化。

当 `time` 一段时间未发生变化时（例如 30 天），可以考虑清除这个账户的关注列表数据。

不过这个方法有个小问题：用户可能依然处于登录和活跃状态，只是关注数据没有变化，所以他的本地数据也就没有更新。这时候删除他的数据是不合适的。

不过这个问题并不严重，因为本地数据被清除之后，前台页面下一次检查更新时会重新获取他的关注数据。

如果储存数据被前台页面请求的时间戳，这样就可以知道这份数据多久没被使用了。这样更好，但是稍显麻烦，我没做。
